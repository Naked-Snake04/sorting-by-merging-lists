# Сортировка посредством слияния списков

## Идея алгоритма
Есть два подхода к реализации данного алгоритма: рекурсивный и итеративный. Мы рассмотрим итеративный подход.

В этом подходе мы разделяем связный список на отсортированные блоки размера степени двойки, а затем объединяем два последовательных блока вместе.

Во-первых, мы делим список на блоки размера один, затем мы объединяем каждые два последовательных блока так, что мы получаем отсортированные блоки размера два.

Во-вторых, мы делим список на блоки размера два, затем мы объединяем каждые два последовательных блока так, что мы получаем отсортированные блоки размера четыре.

Мы продолжаем выполнять эти шаги до тех пор, пока размер блока не достигнет такой степени двойки, которая больше или равна длине данного связного списка. В этом случае наш список будет отсортирован.

В блоках сортировка будет происходить следующим образом: мы создадим целочисленную переменную gap (разрыв), чтобы найти среднюю точку, вокруг которой необходимо отсортировать список. Проблема сводится к объединению двух отсортированных списков. Мы не будем использовать дополнительный список для сохранения объединённого списка. Вместо этого мы объединим списки внутри себя. gap увеличивается в 2 раза на каждой итерации, и процесс повторяется.

### Пошаговое описание алгоритма
Реализуем две функции: функция merge для слияния блоков и MergeSort для реализации самого алгоритма.
#### Детализация функции MergeSort:
1.	Если (*head)==NULL, то алгоритм заканчивает работу.
2.	Создаём указатели * start1, * end1, * start2, * end2 * prevend.
3.	Считаем длину списка.
4.	Если gap (разрыв) больше (изначально он равен 1), чем длина списка, то алгоритм заканчивает работу. Иначе умножаем gap на 2.
5.	Присваиваем start1 = *head
6.	Пока start1 != NULL, создаём две части для слияния.
7.	Указателю на следующий элемент после prevend присваиваем start1. К шагу 4.

##### Детализация шага 3:
3.1	Назначить *current=head, а count = 0
3.2	Сдвигаем current вправо.
3.3	Увеличиваем count на 1. Если current!=NULL , к шагу 3.2. Иначе вернуть значение count, к шагу 4

##### Детализация шага 6:
6.1	Если start1 = NULL, к шагу 7. Иначе к шагу 6.2
6.2	Если это первая итерация цикла(start1=head), то помечаем это (bool isFirstIter = 1).
6.3	Создаём первую часть для слияния.

a.	Создаём counter = gap, end1 = start1
b.	Пока --counter !=0 и end1 можно сдвинуть вправо, сдвигаем end1 вправо.

6.4	Создаём вторую часть для слияния.

a.	Указателю на следующий элемент после end1 присваиваем start 2. Если start 2 = NULL, шагу 6.5.
b.	Создаём counter = gap, end2 = start2
c.	Пока counter !=0 и end2 можно сдвинуть вправо, сдвигаем end2 вправо.
d.	Сохраняем в temp значение после end2 для следующей итерации

6.5	Слияние двух частей с помощью функции merge.
6.6	Если isFirstIter = 1, то назначаем start1 началом списка; иначе назначаем start1 следующим после prevend.
6.7	Назначаем prevend = end2, а start1 = temp. К шагу 6.1

#### Детализация функции merge:
1.	Сравниваем (*start1)->value и (*start2)-> value. Если (*start1)->value и (*start2)-> value, то мы меняем местами эти указатели, а также указатели *end1 и *end2
2.	Создаём указатели * astart, * aend, * bstart, * bend и присваиваем им указатели * start1, * start2, * end1 и * end2, соответственно. Также создаём указатель * bendnext и присваиваем ему (*end2)->next.
3.	Сдвигаем astart вправо по списку, пока не достигнем aend и пока bstart не равен bendnext. Если значение следующего элемента после astart больше чем значение bstart (start2), то меняем элементы местами:
3.1.	Записываем в temp указатель на следующий элемент после bstart (temp = bstart->next)
3.2.	Указателю на следующий элемент после bstart присваиваем указатель на следующий элемент после astart (bstart->next = astart->next)
3.3.	Указателю на следующий элемент после bstart присваиваем указатель на следующий элемент после astart (bstart->next = astart->next)
3.4.	Указателю на следующий элемент после astart присваиваем bstart (astart->next = bstart)
3.5.	Присваиваем bstart = temp;
4.	Если astart=aend, то указателю на следующий элемент после astart присваиваем bstart (astart->next = bstart); иначе *end2 = *end1. Выход из функции.

### Трудоёмкость алгоритма:
Мы делим список на блоки log_2⁡n раз пока не достигнем такой степени двойки, которая больше или равна N длины списка. Затем на каждой итерации мы объединяем каждые два последовательных блока, общая длина которых равна N. Таким образом трудоёмкость алгоритма MergeSort=Θ(n log⁡n).

### Организация данных: 
На входе дан односвязный список длины N. Минимальное число шагов будет достигнуто, если этот список уже отсортирован.
Максимальное число шагов будет достигнуто, если на вход поступит список, упорядоченный по убыванию, т.к. каждый элемент будет сравниваться с каждым.

